import * as vscode from 'vscode';
import { ProjectPlan, LayrConfig, PlanGenerator, APIKeyMissingError, AIServiceError } from './interfaces';
import { GeminiPlanGenerator } from './ai';
import { RuleBasedPlanGenerator } from './rules';

/**
 * Main planner class that orchestrates plan generation
 */
export class Planner {
  private aiGenerator: GeminiPlanGenerator | null = null;
  private ruleGenerator: RuleBasedPlanGenerator;
  private config: LayrConfig;

  constructor() {
    this.ruleGenerator = new RuleBasedPlanGenerator();
    this.config = this.loadConfig();
    this.initializeAIGenerator();
  }

  /**
   * Generate a project plan from a natural language prompt
   */
  async generatePlan(prompt: string): Promise<ProjectPlan> {
    // Try AI generator first if available
    if (this.aiGenerator && await this.aiGenerator.isAvailable()) {
      try {
        const plan = await this.aiGenerator.generatePlan(prompt);
        vscode.window.showInformationMessage('Plan generated using Gemini AI! ðŸ¤–');
        return plan;
      } catch (error) {
        if (error instanceof APIKeyMissingError) {
          vscode.window.showWarningMessage(
            'Gemini API key not configured. Using offline mode. Configure your API key in settings for AI-powered plans.'
          );
        } else if (error instanceof AIServiceError) {
          vscode.window.showWarningMessage(
            `AI service error: ${error.message}. Falling back to offline mode.`
          );
        } else {
          vscode.window.showWarningMessage(
            'Unexpected error with AI service. Falling back to offline mode.'
          );
        }
        
        console.error('AI plan generation failed:', error);
      }
    }

    // Fallback to rule-based generator
    const plan = await this.ruleGenerator.generatePlan(prompt);
    vscode.window.showInformationMessage('Plan generated using offline templates! ðŸ“‹');
    return plan;
  }

  /**
   * Convert a ProjectPlan to Markdown format
   */
  planToMarkdown(plan: ProjectPlan): string {
    const markdown = [];
    
    // Header
    markdown.push(`# ${plan.title}`);
    markdown.push('');
    markdown.push(`*Generated on ${plan.generatedAt.toLocaleDateString()} at ${plan.generatedAt.toLocaleTimeString()} using ${plan.generatedBy === 'ai' ? 'Gemini AI' : 'offline templates'}*`);
    markdown.push('');

    // Overview
    markdown.push('## Overview');
    markdown.push(plan.overview);
    markdown.push('');

    // Requirements
    markdown.push('## Requirements');
    plan.requirements.forEach(req => {
      markdown.push(`- ${req}`);
    });
    markdown.push('');

    // File Structure
    markdown.push('## File Structure');
    markdown.push('```');
    this.renderFileStructure(plan.fileStructure, markdown, 0);
    markdown.push('```');
    markdown.push('');

    // Next Steps
    markdown.push('## Next Steps');
    plan.nextSteps.forEach((step, index) => {
      const checkbox = step.completed ? '[x]' : '[ ]';
      const priority = step.priority === 'high' ? 'ðŸ”´' : step.priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
      const time = step.estimatedTime ? ` (${step.estimatedTime})` : '';
      markdown.push(`${index + 1}. ${checkbox} ${priority} ${step.description}${time}`);
      
      if (step.dependencies && step.dependencies.length > 0) {
        markdown.push(`   - *Depends on: ${step.dependencies.join(', ')}*`);
      }
    });
    markdown.push('');

    // Footer
    markdown.push('---');
    markdown.push('*Generated by Layr - AI Planning Layer for VS Code*');

    return markdown.join('\n');
  }

  /**
   * Refresh configuration and reinitialize AI generator
   */
  refreshConfig(): void {
    this.config = this.loadConfig();
    this.initializeAIGenerator();
  }

  private loadConfig(): LayrConfig {
    const config = vscode.workspace.getConfiguration('layr');
    const apiKey = config.get<string>('geminiApiKey') || process.env.GEMINI_API_KEY || '';
    
    return {
      geminiApiKey: apiKey
    };
  }

  private initializeAIGenerator(): void {
    if (this.config.geminiApiKey && this.config.geminiApiKey.trim() !== '') {
      this.aiGenerator = new GeminiPlanGenerator(this.config.geminiApiKey);
    } else {
      this.aiGenerator = null;
    }
  }

  private renderFileStructure(items: any[], markdown: string[], depth: number): void {
    const indent = '  '.repeat(depth);
    
    items.forEach(item => {
      const icon = item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„';
      const name = item.type === 'directory' ? `${item.name}/` : item.name;
      markdown.push(`${indent}${icon} ${name}`);
      
      if (item.children && item.children.length > 0) {
        this.renderFileStructure(item.children, markdown, depth + 1);
      }
    });
  }
}

// Export the main planner instance
export const planner = new Planner();

// Export types for use in extension
export * from './interfaces';